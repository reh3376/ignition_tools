"""Code Analyzer for AI Assistant Module.

Adapted from docs/crawl test/knowledge_graph/ai_script_analyzer.py
Parses Python scripts generated by AI coding assistants using AST to extract:
- Import statements and their usage
- Class instantiations and method calls
- Function calls with parameters
- Attribute access patterns
- Variable type tracking
"""

import ast
import logging
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


@dataclass
class ImportInfo:
    """Information about an import statement."""

    module: str
    name: str
    alias: str | None = None
    is_from_import: bool = False
    line_number: int = 0


@dataclass
class MethodCall:
    """Information about a method call."""

    object_name: str
    method_name: str
    args: list[str]
    kwargs: dict[str, str]
    line_number: int
    object_type: str | None = None  # Inferred class type


@dataclass
class AttributeAccess:
    """Information about attribute access."""

    object_name: str
    attribute_name: str
    line_number: int
    object_type: str | None = None  # Inferred class type


@dataclass
class FunctionCall:
    """Information about a function call."""

    function_name: str
    args: list[str]
    kwargs: dict[str, str]
    line_number: int
    full_name: str | None = None  # Module.function_name


@dataclass
class ClassInstantiation:
    """Information about class instantiation."""

    variable_name: str
    class_name: str
    args: list[str]
    kwargs: dict[str, str]
    line_number: int
    full_class_name: str | None = None  # Module.ClassName


@dataclass
class AnalysisResult:
    """Complete analysis results for a Python script."""

    file_path: str
    imports: list[ImportInfo] = field(default_factory=list)
    class_instantiations: list[ClassInstantiation] = field(default_factory=list)
    method_calls: list[MethodCall] = field(default_factory=list)
    attribute_accesses: list[AttributeAccess] = field(default_factory=list)
    function_calls: list[FunctionCall] = field(default_factory=list)
    variable_types: dict[str, str] = field(
        default_factory=dict
    )  # variable_name -> class_type
    errors: list[str] = field(default_factory=list)


class CodeAnalyzer:
    """Analyzes AI-generated Python scripts for validation against knowledge graph."""

    def __init__(self) -> Any:
        self.import_map: dict[str, str] = {}  # alias -> actual_module_name
        self.variable_types: dict[str, str] = {}  # variable_name -> class_type
        self.context_manager_vars: dict[str, tuple[int, int, str]] = (
            {}
        )  # var_name -> (start_line, end_line, type)
        self.processed_calls: set[int] = set()
        self.method_call_attributes: set[int] = set()

    def analyze_script(self, script_path: str) -> AnalysisResult:
        """Analyze a Python script and extract all relevant information."""
        try:
            with open(script_path, encoding="utf-8") as f:
                content = f.read()

            tree = ast.parse(content)
            result = AnalysisResult(file_path=script_path)

            # Reset state for new analysis
            self.import_map.clear()
            self.variable_types.clear()
            self.context_manager_vars.clear()
            self.processed_calls.clear()
            self.method_call_attributes.clear()

            # First pass: collect imports and build import map
            for node in ast.walk(tree):
                if isinstance(node, ast.Import | ast.ImportFrom):
                    self._extract_imports(node, result)

            # Second pass: analyze usage patterns
            for node in ast.walk(tree):
                self._analyze_node(node, result)

            # set inferred types on method calls and attribute accesses
            self._infer_object_types(result)

            result.variable_types = self.variable_types.copy()

            return result

        except Exception as e:
            error_msg = f"Failed to analyze script {script_path}: {e!s}"
            logger.error(error_msg)
            result = AnalysisResult(file_path=script_path)
            result.errors.append(error_msg)
            return result

    def analyze_code_string(
        self, code: str, file_path: str = "<string>"
    ) -> AnalysisResult:
        """Analyze Python code from a string instead of file."""
        try:
            tree = ast.parse(code)
            result = AnalysisResult(file_path=file_path)

            # Reset state for new analysis
            self.import_map.clear()
            self.variable_types.clear()
            self.context_manager_vars.clear()
            self.processed_calls.clear()
            self.method_call_attributes.clear()

            # First pass: collect imports and build import map
            for node in ast.walk(tree):
                if isinstance(node, ast.Import | ast.ImportFrom):
                    self._extract_imports(node, result)

            # Second pass: analyze usage patterns
            for node in ast.walk(tree):
                self._analyze_node(node, result)

            # set inferred types on method calls and attribute accesses
            self._infer_object_types(result)

            result.variable_types = self.variable_types.copy()

            return result

        except Exception as e:
            error_msg = f"Failed to analyze code: {e!s}"
            logger.error(error_msg)
            result = AnalysisResult(file_path=file_path)
            result.errors.append(error_msg)
            return result

    def _extract_imports(self, node: ast.AST, result: AnalysisResult) -> Any:
        """Extract import information and build import mapping."""
        line_num = getattr(node, "lineno", 0)

        if isinstance(node, ast.Import):
            for alias in node.names:
                import_name = alias.name
                alias_name = alias.asname or import_name

                result.imports.append(
                    ImportInfo(
                        module=import_name,
                        name=import_name,
                        alias=alias.asname,
                        is_from_import=False,
                        line_number=line_num,
                    )
                )

                self.import_map[alias_name] = import_name

        elif isinstance(node, ast.ImportFrom):
            module = node.module or ""
            for alias in node.names:
                import_name = alias.name
                alias_name = alias.asname or import_name

                result.imports.append(
                    ImportInfo(
                        module=module,
                        name=import_name,
                        alias=alias.asname,
                        is_from_import=True,
                        line_number=line_num,
                    )
                )

                # Map alias to full module.name
                if module:
                    full_name = f"{module}.{import_name}"
                    self.import_map[alias_name] = full_name
                else:
                    self.import_map[alias_name] = import_name

    def _analyze_node(self, node: ast.AST, result: AnalysisResult) -> Any:
        """Analyze individual AST nodes for usage patterns."""
        # Assignments (class instantiations and method call results)
        if isinstance(node, ast.Assign):
            if len(node.targets) == 1 and isinstance(node.targets[0], ast.Name):
                if isinstance(node.value, ast.Call):
                    # Check if it's a class instantiation or method call
                    if isinstance(node.value.func, ast.Name):
                        # Direct function/class call
                        self._extract_class_instantiation(node, result)
                        # Mark this call as processed to avoid duplicate processing
                        self.processed_calls.add(id(node.value))
                    elif isinstance(node.value.func, ast.Attribute):
                        # Method call - track the variable assignment for type inference
                        var_name = node.targets[0].id
                        self._track_method_result_assignment(node.value, var_name)

        # Method calls and function calls
        elif isinstance(node, ast.Call):
            if id(node) not in self.processed_calls:
                if isinstance(node.func, ast.Attribute):
                    self._extract_method_call(node, result)
                elif isinstance(node.func, ast.Name):
                    self._extract_function_call(node, result)

        # Attribute access
        elif isinstance(node, ast.Attribute):
            if id(node) not in self.method_call_attributes:
                self._extract_attribute_access(node, result)

        # Context managers (with statements)
        elif isinstance(node, ast.With | ast.AsyncWith):
            if isinstance(node, ast.AsyncWith):
                self._handle_async_with(node, result)
            else:
                self._handle_with(node, result)

    def _extract_class_instantiation(
        self, node: ast.Assign, result: AnalysisResult
    ) -> Any:
        """Extract class instantiation from assignment."""
        if not isinstance(node.value, ast.Call):
            return

        line_num = getattr(node, "lineno", 0)
        if not isinstance(node.targets[0], ast.Name):
            return
        var_name = node.targets[0].id
        call_node = node.value

        # Get function/class name
        func_name = self._get_name_from_call(call_node)
        if not func_name:
            return

        # Resolve full name using import map
        full_name = self._resolve_full_name(func_name)

        # Extract arguments
        args = [self._get_arg_representation(arg) for arg in call_node.args]
        kwargs = {}
        for keyword in call_node.keywords:
            if keyword.arg:
                kwargs[keyword.arg] = self._get_arg_representation(keyword.value)

        # Check if it's likely a class instantiation
        if self._is_likely_class_instantiation(func_name, full_name):
            instantiation = ClassInstantiation(
                variable_name=var_name,
                class_name=func_name,
                args=args,
                kwargs=kwargs,
                line_number=line_num,
                full_class_name=full_name,
            )
            result.class_instantiations.append(instantiation)

            # Track variable type for future method calls
            self.variable_types[var_name] = func_name

    def _extract_method_call(self, node: ast.Call, result: AnalysisResult) -> Any:
        """Extract method call information."""
        if not isinstance(node.func, ast.Attribute):
            return

        line_num = getattr(node, "lineno", 0)

        # Get object name and method name
        obj_name = self._get_name_from_node(node.func.value)
        method_name = node.func.attr

        if not obj_name:
            return

        # Mark attribute as processed to avoid duplicate extraction
        self.method_call_attributes.add(id(node.func))

        # Extract arguments
        args = [self._get_arg_representation(arg) for arg in node.args]
        kwargs = {}
        for keyword in node.keywords:
            if keyword.arg:
                kwargs[keyword.arg] = self._get_arg_representation(keyword.value)

        method_call = MethodCall(
            object_name=obj_name,
            method_name=method_name,
            args=args,
            kwargs=kwargs,
            line_number=line_num,
        )
        result.method_calls.append(method_call)

    def _extract_function_call(self, node: ast.Call, result: AnalysisResult) -> Any:
        """Extract function call information."""
        if not isinstance(node.func, ast.Name):
            return

        line_num = getattr(node, "lineno", 0)
        func_name = node.func.id

        # Resolve full name using import map
        full_name = self._resolve_full_name(func_name)

        # Extract arguments
        args = [self._get_arg_representation(arg) for arg in node.args]
        kwargs = {}
        for keyword in node.keywords:
            if keyword.arg:
                kwargs[keyword.arg] = self._get_arg_representation(keyword.value)

        function_call = FunctionCall(
            function_name=func_name,
            args=args,
            kwargs=kwargs,
            line_number=line_num,
            full_name=full_name,
        )
        result.function_calls.append(function_call)

    def _extract_attribute_access(
        self, node: ast.Attribute, result: AnalysisResult
    ) -> Any:
        """Extract attribute access information."""
        line_num = getattr(node, "lineno", 0)

        obj_name = self._get_name_from_node(node.value)
        attr_name = node.attr

        if not obj_name:
            return

        attribute_access = AttributeAccess(
            object_name=obj_name,
            attribute_name=attr_name,
            line_number=line_num,
        )
        result.attribute_accesses.append(attribute_access)

    def _infer_object_types(self, result: AnalysisResult) -> Any:
        """Infer object types for method calls and attribute accesses."""
        # set object types for method calls
        for method_call in result.method_calls:
            obj_type = self._get_context_aware_type(
                method_call.object_name, method_call.line_number
            )
            method_call.object_type = obj_type

        # set object types for attribute accesses
        for attr_access in result.attribute_accesses:
            obj_type = self._get_context_aware_type(
                attr_access.object_name, attr_access.line_number
            )
            attr_access.object_type = obj_type

    def _get_context_aware_type(self, var_name: str, line_number: int) -> str | None:
        """Get variable type considering context managers."""
        # Check if variable is in a context manager scope
        for cm_var, (
            start_line,
            end_line,
            cm_type,
        ) in self.context_manager_vars.items():
            if cm_var == var_name and start_line <= line_number <= end_line:
                return cm_type

        # Fall back to regular variable type tracking
        return self.variable_types.get(var_name)

    def _get_name_from_call(self, node: ast.AST) -> str | None:
        """Get the name from a call node."""
        if isinstance(node, ast.Call):
            return self._get_name_from_node(node.func)
        return None

    def _get_name_from_node(self, node: ast.AST) -> str | None:
        """Get name from various AST node types."""
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            obj_name = self._get_name_from_node(node.value)
            if obj_name:
                return f"{obj_name}.{node.attr}"
            return node.attr
        return None

    def _get_arg_representation(self, node: ast.AST) -> str:
        """Get string representation of an argument."""
        if isinstance(node, ast.Constant):
            return repr(node.value)
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            obj_name = self._get_name_from_node(node.value)
            if obj_name:
                return f"{obj_name}.{node.attr}"
            return node.attr
        else:
            return f"<{type(node).__name__}>"

    def _is_likely_class_instantiation(
        self, func_name: str, full_name: str | None
    ) -> bool:
        """Determine if a function call is likely a class instantiation."""
        # Heuristics for class instantiation detection
        if func_name[0].isupper():  # Class names typically start with uppercase
            return True

        # Check against known class patterns
        known_classes = {
            "AsyncWebCrawler",
            "Client",
            "CrossEncoder",
            "KnowledgeGraphValidator",
            "DirectNeo4jExtractor",
            "HallucinationReporter",
            "AIScriptAnalyzer",
        }

        if func_name in known_classes:
            return True

        if full_name:
            class_name = full_name.split(".")[-1]
            if class_name in known_classes or class_name[0].isupper():
                return True

        return False

    def _track_method_result_assignment(
        self, call_node: ast.Call, var_name: str
    ) -> Any:
        """Track variable assignments from method calls for type inference."""
        # This could be enhanced to infer return types from method calls
        pass

    def _handle_async_with(self, node: ast.AsyncWith, result: AnalysisResult) -> Any:
        """Handle async with statements for context manager tracking."""
        for item in node.items:
            if item.optional_vars and isinstance(item.optional_vars, ast.Name):
                var_name = item.optional_vars.id
                start_line = getattr(node, "lineno", 0)
                end_line = getattr(node, "end_lineno", start_line + 100)

                # Try to infer the type from the context manager
                cm_type = None
                if isinstance(item.context_expr, ast.Call):
                    cm_name = self._get_name_from_call(item.context_expr)
                    if cm_name:
                        cm_type = cm_name

                if cm_type:
                    self.context_manager_vars[var_name] = (
                        start_line,
                        end_line,
                        cm_type,
                    )
                    self.variable_types[var_name] = cm_type

                # Also extract as class instantiation if applicable
                if isinstance(item.context_expr, ast.Call):
                    # Create a fake assignment node for extraction
                    fake_assign = ast.Assign(
                        targets=[ast.Name(id=var_name)],
                        value=item.context_expr,
                        lineno=start_line,
                    )
                    self._extract_class_instantiation(fake_assign, result)

    def _handle_with(self, node: ast.With, result: AnalysisResult) -> Any:
        """Handle regular with statements for context manager tracking."""
        for item in node.items:
            if item.optional_vars and isinstance(item.optional_vars, ast.Name):
                var_name = item.optional_vars.id
                start_line = getattr(node, "lineno", 0)
                end_line = getattr(node, "end_lineno", start_line + 100)

                # Try to infer the type from the context manager
                cm_type = None
                if isinstance(item.context_expr, ast.Call):
                    cm_name = self._get_name_from_call(item.context_expr)
                    if cm_name:
                        cm_type = cm_name

                if cm_type:
                    self.context_manager_vars[var_name] = (
                        start_line,
                        end_line,
                        cm_type,
                    )
                    self.variable_types[var_name] = cm_type

    def _resolve_full_name(self, name: str) -> str | None:
        """Resolve a name to its full module.name using import map."""
        return self.import_map.get(name)


def analyze_ai_script(script_path: str) -> AnalysisResult:
    """Convenience function to analyze a script."""
    analyzer = CodeAnalyzer()
    return analyzer.analyze_script(script_path)


def analyze_ai_code(code: str, file_path: str = "<string>") -> AnalysisResult:
    """Convenience function to analyze code from string."""
    analyzer = CodeAnalyzer()
    return analyzer.analyze_code_string(code, file_path)
